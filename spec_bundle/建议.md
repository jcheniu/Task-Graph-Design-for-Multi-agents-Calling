# 对《思路.txt》的疑点、潜在 bug、不可实现点与建议

> 结论：整体是“用 DAG 编排多 agent 的同步/选择/回滚”的抽象，但目前在 **状态机定义、边的语义一致性、并发与持久化、以及 n->1 / 1->n 边的触发条件** 上存在多处逻辑缺口。建议先把“运行时语义”收敛成一个可验证的事件驱动模型，再写类。

## 1. 我不理解/定义不清的地方（会导致实现分歧）

1) **“激活/等待/发射/关闭”是节点级状态，但边也有状态**
- Node1/Node2：关闭→激活→等待→发射→关闭
- SyncEdge/ChooseEdge：关闭→等待→激活→关闭
- GateEdge/BackEdge：关闭↔激活

你已澄清并选择的状态机方案（已记录）：C. 保留四态但含义调整
- 关闭(OFF/IDLE)：节点不在运行；等待输入就绪（仅观察 enabled=true 且 active=true 的输入边集合）。
- 激活(ACTIVE/START)：节点判定输入准备就绪后，读取各输入边队列的“本轮消息”（按你已定的顺序与快照规则拼接），并并发启动 agents tasks。
- 等待(WAITING)：agents tasks 运行中；节点实时监测各 task 完成状态。
- 发射(EMIT)：所有 agents 完成后，将最终输出写入其 enabled=true 的输出边队列（使这些边 active=true）；然后对本轮参与的输入边执行 `ack_one()`；最后回到关闭态。

（注：enabled/active/队列/ack 的语义不变，四态只用于节点对外暴露运行阶段。）

你已澄清的运行时语义（已记录）：
- **边负责维护 prompt**：边把前继节点输出写入“外部固定路径”的存储，并维护自身 `激活` 状态。
- **节点不会把输出“推送给边”作为触发源**；相反，节点在需要输入时会：
  1) 索引/遍历连接自己的、可用且激活的输入边
  2) 从这些边的外部存储读取“最新 prompt”
  3) 按确定的顺序拼接/打包为完整输入 prompt
  4) 通过 SDK 交给本节点 agents 阅读/执行

仍需你进一步界定的点（避免实现歧义）：
- “边何时被设置为激活？”：既然节点是拉取读取，那边进入激活态的条件是“前继节点写入完成”还是“被后继节点第一次读取后才激活”？目前描述更像前者。
- “前继节点输出如何进入边的外部存储？”：虽然节点不负责推送，但仍需要一个写入动作来源（例如：前继节点发射态调用 edge.write；或 edge 订阅前继节点输出事件）。建议你把这个写入触发点明确成一个唯一机制，否则实现时仍会出现双触发或漏触发。

2) **“输入接收状态 bool 列表”与“输入确认开关”关系不清**

你已澄清的定义（已记录）：
- **边的激活是持续状态**：已激活的输入边会保持激活，直到后继节点“确认消费”。
- 节点有一个 `bool 输入确认开关`：当其为 `false` 表示“还没读完/还没确认消费”；此时已经激活的边保持激活。

你最终的取舍（已记录）：删除 `输入接收状态 bool 列表`
- 由于输入边可能来自“边组/子边”，用一个 bool 列表去对齐会非常脆弱。
- 改为规则驱动：节点的就绪条件由其**当前参与的输入边集合**决定。
  - 参与集合定义：`enabled==true` 的输入边（或子边）视为“存在”，`enabled==false` 直接 skip。
  - 就绪条件：所有 `enabled==true` 的输入边都必须 `active==true`（队列非空）才触发节点激活。

- 如果某条输入边处于激活，但其外部存储里没有“新消息”（例如重复读取同一条最新 prompt），节点如何避免重复消费？
  - 你最终确认：采用 **按消息确认（ACK one message）** 的语义（与 FIFO 队列一致）。
  - 消费协议因此可以落成：节点在本轮 agents 全部完成后，对每条参与本轮输入的已激活输入边执行 `ack_one()`，确认并弹出（pop）队头 1 条消息。
  - 边的激活条件：队列非空则保持激活；队列为空才关闭。

3) **提示词拼接规则不明确**

你已澄清的规则（已记录）：
- 拼接顺序采用 **A. 按节点维护的输入边列表顺序（list index）**，不按时间戳排序。
- 每条边维护 **历史列表**（用于回溯、可控），但节点在本轮只读取该边的 **最后一条（最新写入/时间戳最新）**。
- 并发一致性采用 **快照原则**：以“本轮读取开始时刻”为准，只读取时间戳正确（不晚于快照时刻）的那一条，避免读到半途更新导致的不一致。
- 输入内容格式采用 **结构化块（B）**：prompt 中应标注来源 edge（至少包含 edge 标签/ID 和时间戳），以便 agents 明确区分来源。
- “假输入”的语义：假输入主要来自 **回滚/重跑** 场景，通常由后续（不一定是直接后继的）checkpoint 节点通过 BackEdge 打回的建议，属于必须阅读的输入。
  - 你约定：若为假输入，则来源 edge 一定是 **BackEdge**；否则即为真输入。

仍需你进一步界定的点（建议补进 spec，避免实现歧义）：
- 快照时刻如何定义与传播：是节点进入“激活态”的时间戳、还是开始拼接 prompt 的时间戳？如果是后者，需要在读取每条边时都做 `<= snapshot_ts` 的选择。
- BackEdge “不一定直接后继”意味着可能跨层回流：需要明确是否允许跨越多个中间节点直接连接；以及如何在 DAG 里避免形成环导致无穷回滚（仅靠计数器可能不足）。
- 结构化块的具体格式建议固定（便于 agents 解析），例如：
  - `[[EDGE:{edge_id} TYPE:{edge_type} TS:{ts}]]\n{content}\n[[/EDGE]]`

4) **Node2 的“后继节点开关”与 ChooseEdge 的联动语义不完整**

你已澄清/补充的设计决定（已记录）：
- ChooseEdge 实际是“一组很多条边”的管理对象：底层是多条 **真输出→真输入** 的子边；为了方便管理，把这一组子边封装成 1 个 ChooseEdge obj。
- 因此 ChooseEdge 的 `边标签` 不应是单个 string，而应改为 **string 列表**，长度=子边数量。
- `真后继节点开关`（原“后继节点开关”）的长度 **只对应该 ChooseEdge 的子边数量**，并且子边数量=该 ChooseEdge 连接的后继节点数。
- 开关语义：开关打开意味着“允许前节点向对应后继节点传递内容”（传递载体仍是边自身保存的 prompt）。
- 约束：你设想“任意两个节点之间同方向的边数量 ≤ 1”，因此“按边开关”和“按后继节点 id 开关”在该约束下等价。
- checkpoint(Node2) 的 agents 输出采用 **bool 向量（与后继列表同序）** 来修改开关。

你新发现并提出的关键 bug/改进（已记录）：BackEdge 不应只有一条
- checkpoint 需要能选择“使用哪一条复跑边/打回边”。因此 BackEdge 也应与 ChooseEdge 一样，改成“一组很多条边”的管理对象：
  - `后继节点对象` 由单个改为 **NODE 列表**（对应各条子边的目标）
  - `边标签` 由单个改为 **string 列表**
- 为了区分真/假两类后继选择，Node2 需要增加并区分两组开关：
  - `真后继节点开关: bool列表 shape=(m,) 默认全 false`（给 ChooseEdge 用）
  - `假后继节点开关: bool列表 shape=(m,) 默认全 false`（给 BackEdge 用）
- Node2 需要额外的“输入模板”，允许 agents 根据模板输出，来改变上述两组开关（真/假）。

我替你把输出格式先定一个可解析的最小规范（你可再改）：
- checkpoint agents 必须输出一个 JSON 对象，包含两组同序 bool 向量：
  - `true_successors_mask`: 与 ChooseEdge 后继列表同序
  - `false_successors_mask`: 与 BackEdge(回滚)后继列表同序
- 若某一组不使用，则输出空数组或全 false。

仍需你进一步界定的点（否则实现仍会卡住）：
- BackEdge 的“后继节点列表”具体指向谁：是“被打回重跑的上游工作点(WorkVertex)”还是“某个更早的 checkpoint”？（你说“不一定直接后继”，这会影响 DAG 是否允许跨层连边）
- 真/假两组后继列表是否必须同长 m？如果不同长，Node2 的两个 mask 应分别有不同维度，并各自对齐各自的边组。

## 2. 潜在 bug（按严重程度排序）

### 2.1 严重：并发/竞态导致的“丢触发、重复触发”
你把 prompt 存在“脚本外固定路径的 md 文件”里，并通过状态（激活/关闭）判断事件发生。

典型竞态：
- 边写入 md 后立刻“变回关闭态”，节点如果是轮询状态，很可能错过“激活”瞬间。
- 多个 agent/线程同时写同一个 md 文件（或同一路径）会发生覆盖/交错写，导致内容损坏。
- “最新储存内容”如果用文件末尾读取，在并发写入时可能读到半行或不完整块。

### 2.2 严重：SyncEdge/ChooseEdge 的等待条件会导致死锁
SyncEdge：等待态直到所有 n 个前节点输出都存入表。

死锁来源：
- 如果其中某个前节点分支永远不触发（例如由 ChooseEdge 选择掉了），SyncEdge 将永久等待。

### 2.2 严重：SyncEdge/ChooseEdge 的等待条件会导致死锁

你最终的取舍（已记录）：删除 SyncEdge，由后继节点自行完成 n 路同步
- 触发条件：当 required 的输入边都满足 `enabled==true` 且 `active==true`（队列非空）时，节点激活。
- 激活后：节点分别读取各输入边队列的 **队头** 消息，再按你已定的顺序与结构化块格式拼接成 prompt，交给本节点 agents。
- 本轮完成后：节点对本轮参与的每条输入边执行 `ack_one()`，推进各自 offset。

你提出的新算法（已记录）：用 enable 传播把“未被选择的子分支”从运行时图中移除
- 所有 EDGE 类：保留 `bool enabled`。
- 所有 NODE 类：保留 `bool enabled`。
- ChooseEdge 是“边组对象”，其每条子边都有独立 enabled：
  - 若某条子边未被 checkpoint 选择，则仅将**该子边** `enabled=false`（不会一刀切禁用整个后继节点或整组边）。
- 节点禁用传播规则（需要实时检查/维护）：
  - 若某个 node 的所有输入边（包括所有子边）均满足 `enabled==false`，则将 `node.enabled=false`。
  - 当 `node.enabled=false` 时，同时将该 node 的所有输出边都设为 `enabled=false`。
- 执行规则：
  - 对于 `enabled==false` 的点和边：所有相关操作都 **skip**，视为不存在。
  - 但若某个点/边当前处于 `active`（激活）状态：允许其把“手头的事情做完”，待其状态从 active 退出后再开始 skip（相当于“延迟生效的 disable”）。
    - 你确认采用 **C（节点与边都延迟生效）**：
      - 对 node：若其处于 active（正在本轮运行中），则允许其完成本轮（agents 结束/发射结束/确认消费）后再应用 enabled 变更。
      - 对 edge：若其处于 active（队列非空且待消费），则允许其完成当前应完成的消费/写入边界后再应用 enabled 变更。

你补充并澄清的 enable 传播反向规则（已记录）：
- 若某个 node 只要存在任意一条输入边满足 `enabled==true`，则该 `node.enabled==true`。
- 且当 `node.enabled` 被恢复为 true 时，应将该 node 的所有输出边 `enabled==true`（恢复可达性）。

（这意味着 node/edge 的 enabled 可能在运行中双向切换：disabled↔enabled，需要实现里防止重复反复传播导致震荡。）

### 2.3 严重：BackEdge 的计数器逻辑存在 off-by-one/语义不清

你已更新 BackEdge 设计（已记录）：BackEdge 为“边组对象”，包含多条回滚子边，由 checkpoint 选择使用哪一条。

你最终确认的计数器语义（已记录）：
- **计数器按“子边”独立计算（B）**：每条回滚子边各自维护一个剩余次数计数器。
- “激活一次”的定义（A）：每当 checkpoint 选择并通过某条回滚子边 **发出一次回滚消息**，该子边计数器 -1。
- 默认=3 的含义：**最多允许 3 次**（不是 4 次）。

据此建议把失效条件写成无歧义形式：
- `remaining` 初始=3
- 每次发出回滚消息后：`remaining -= 1`
- 当 `remaining <= 0` 时，将该子边 `enabled=false`（或该子边 gate=false），使其后续不可再被选择

（这也避免了你旧规则里 `remaining < 0` 导致的 off-by-one。）

### 2.4 中等：Node2 禁止“checkpoint 后继也是 checkpoint”
最终规则（你已确认）：
- 若 Node2(checkpoint) 的后继节点也是 Node2(checkpoint)，则直接报错并拒绝构图/拒绝连接。

### 2.5 中等：GateEdge 的一致性校验与“真/假输入输出列表”容易不一致

你最终选择的策略（已记录）：删除“真/假”人工列表，完全由 edge.type 推导
- 你希望：可以直接删除所有“真输入/假输入/真输出/假输出”这类人工维护的列表概念。
- Node 仅需维护连接关系（例如 `in_edges`/`out_edges`，以及边组对象）。
- “回滚”分支的选择规则：checkpoint 只允许选择 `edge.type == BackEdge` 的边（或 BackEdge 边组里的子边）。
- 因此一致性校验应简化为：
  - edge.from / edge.to 的拓扑连接正确
  - edge.type 与其用途匹配（例如 BackEdge 不应被当作普通前向边；SyncEdge 的前驱数满足 n->1 等）

这样可以避免“同一条边要被手动挂进多个列表”导致的配置失误。

## 3. 不可实现/实现代价极高的点

1) **“实时监测所有 agents 完成状态”**

你最终选择（已记录）：B. 并发异步
- Node 在激活后，应以并发/异步方式启动多个 agents（futures/tasks）。
- 等待态的语义成立：可以实时监测/订阅各 agent 的完成状态。
- 当所有 agents 完成后，节点进入发射态。

（若你后端实现上仍需要同步接口，可以在最外层 await 所有 tasks，但内部仍以异步并发运行。）

2) **用 md 文件作为运行时消息队列**

你已确定的落盘方案（已记录）：采用每条子边独立的 append-only JSONL + 消费指针
- 存储粒度：**每条子边一个文件**（例如每条 edge/sub-edge 一个 `E{edge_id}.jsonl`），降低并发冲突。
- 文件格式：**JSONL**（一行一个事件/消息），用于可控、可复盘。
- 入队：仅追加写（append-only），不重写文件。
- 出队/确认：不物理删除内容；采用 **消费指针/offset**（例如记录 `last_consumed_index` 或 `last_consumed_ts`），以便回放与审计。

仍需你进一步界定的点：
- 消费指针存放位置：单独的 `.state.json` / SQLite / 运行时内存+定期落盘？（避免与消息文件互相竞争写锁）
- 多进程/崩溃恢复时，如何保证“追加写”与“更新 offset”原子性（否则可能出现消息已写入但 offset 丢失、或 offset 前移但消息未写全）。

3) **“仅根据 6 obj 构造图 (DAG)”与“动态选择后继”之间的矛盾**
如果图结构是静态 DAG.dot，那么 ChooseEdge/Node2 动态改变后继开关，本质是在运行时改变可达性。
- 这没问题，但需要把“运行时激活子图”与“静态拓扑结构”分离，否则可视化/推理会混乱。

## 4. 不合理/建议调整的设计点

1) **状态机建议收敛为“事件驱动”而不是“状态轮询”**
把“边激活”视为一个事件：`EdgeReceivedPrompt(edge_id, payload, ts)`。
节点只需要订阅其输入边事件，并维护“已收到哪些输入”的缓存。

2) **Node 的输入条件应当由“需要的输入集合”定义（mask），而不是 bool 列表 + 边瞬时激活状态**
定义：
- required_inputs: set(edge_id)
- optional_inputs: set(edge_id)
触发规则：required 全到即可触发，optional 有则拼进去。

3) **ChooseEdge/SyncEdge 要明确与“动态分支”协作**
- ChooseEdge 选择 k 条“输出边”更自然（1->n 是从当前节点发往多个后继），而不是“在 n 个前节点中选 k 个作为输入”。目前写法是“前节点列表所有前节点对象”，更像 n->1。
- 如果坚持 “n 前驱收敛到 1 后继 + 从中选 k 个”，那它其实是“选择性同步边”，需要明确：未被选中的前驱输入不应该参与等待条件。

4) **持久化建议改为 append-only 日志 + 索引**
如果你坚持“外部文件可观察、可回放”，建议：
- 每条 edge 一个 `E01.jsonl` 追加写，每行一个事件（ts, from, to, content_hash, content/path）。
- 节点拼 prompt 时按事件序号/ts 做确定性排序。

## 5. 一个可落地的最小建议（优先级最高）

把系统先约束成一个最小可测试内核：

- **单进程、事件驱动、无“激活瞬时态轮询”**
- Node 只维护：收到的输入事件缓存 + 触发条件（required set）
- Edge 只做：追加写事件（内存队列或 JSONL），不需要“关闭/激活”状态来模拟消息
- Sync/Choose/Back 都实现为“边的事件路由规则”，不要引入第二套状态机

验收标准（建议你写单测的行为）：
1) 同一批输入事件到达顺序不同，Node 构造的 prompt 顺序仍确定（可复现）。
2) 动态选择后，未选择的分支不会导致 Sync 永久等待。
3) BackEdge 的计数器行为精确符合预期（例如最多 N 次）。

---

## 7. 运行时判定优先级（最终确认）

你已确认的优先级（已记录）：
1) `enabled == false`：直接 skip，视为不存在（无论 `active` 如何）。
2) `enabled == true` 且 `active == false`：存在但未就绪（阻塞等待）。
3) `enabled == true` 且 `active == true`：就绪可读；节点读取队头消息运行，本轮结束后对参与边执行 `ack_one()` 推进 offset；若 offset 已到队列末尾使队列空，则 `active` 变为 false。
